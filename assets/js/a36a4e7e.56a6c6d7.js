(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4807],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),p=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(i.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=a,h=m["".concat(i,".").concat(d)]||m[d]||l[d]||o;return n?r.createElement(h,c(c({ref:t},u),{},{components:n})):r.createElement(h,c({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,c=new Array(o);c[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,c[1]=s;for(var p=2;p<o;p++)c[p]=n[p];return r.createElement.apply(null,c)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6391:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return p},toc:function(){return u},default:function(){return m}});var r=n(2122),a=n(9756),o=(n(7294),n(3905)),c=["components"],s={title:"cw20-atomic-swap Spec",sidebar_position:7},i="Atomic Swaps",p={unversionedId:"cw-plus/cw20/cw20-atomic-swap-spec",id:"cw-plus/cw20/cw20-atomic-swap-spec",isDocsHomePage:!1,title:"cw20-atomic-swap Spec",description:"cw20-atomic-swap source",source:"@site/docs/cw-plus/cw20/cw20-atomic-swap-spec.md",sourceDirName:"cw-plus/cw20",slug:"/cw-plus/cw20/cw20-atomic-swap-spec",permalink:"/docs/0.14/cw-plus/cw20/cw20-atomic-swap-spec",editUrl:"https://github.com/CosmWasm/docs/edit/main/docs/cw-plus/cw20/cw20-atomic-swap-spec.md",version:"current",sidebarPosition:7,frontMatter:{title:"cw20-atomic-swap Spec",sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"cw20-staking Spec",permalink:"/docs/0.14/cw-plus/cw20/cw20-staking-spec"},next:{title:"cw721 Spec",permalink:"/docs/0.14/cw-plus/cw721/spec"}},u=[{value:"Token types",id:"token-types",children:[]}],l={toc:u};function m(e){var t=e.components,n=(0,a.Z)(e,c);return(0,o.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"atomic-swaps"},"Atomic Swaps"),(0,o.kt)("p",null,"cw20-atomic-swap source\ncode: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm-plus/tree/master/contracts/cw20-atomic-swap"},"https://github.com/CosmWasm/cosmwasm-plus/tree/master/contracts/cw20-atomic-swap")),(0,o.kt)("p",null,"This is a contract that allows users to execute atomic swaps. It implements one side of an atomic swap. The other side\ncan be realized by an equivalent contract in the same blockchain or, typically, on a different blockchain."),(0,o.kt)("p",null,"Each side of an atomic swap has a sender, a recipient, a hash, and a timeout. It also has a unique id (for future calls\nto reference it). The hash is a sha256-encoded 32-bytes long phrase. The timeout can be either time-based (seconds since\nmidnight, January 1, 1970), or block height based."),(0,o.kt)("p",null,"The basic function is, the sender chooses a 32-bytes long phrase as preimage, hashes it, and then uses the hash to\ncreate a swap with funds. Before the timeout, anybody that knows the preimage may decide to release the funds to the\noriginal recipient. After the timeout (and if no release has been executed), anyone can refund the locked tokens to the\noriginal sender. On the other side of the swap the process is similar, with sender and recipient exchanged. The hash\nmust be the same, so the first sender can claim the funds, revealing the preimage and triggering the swap."),(0,o.kt)("p",null,"See the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/iov-one/iov-core/blob/master/docs/atomic-swap-protocol-v1.md"},"IOV atomic swap spec"),"\nfor details."),(0,o.kt)("h2",{id:"token-types"},"Token types"),(0,o.kt)("p",null,"Currently native tokens are supported; an upcoming version will support cw20 tokens."))}m.isMDXComponent=!0}}]);